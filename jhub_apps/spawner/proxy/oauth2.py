from simpervisor import SupervisedProcess
from typing import Dict, List
import socket
import click

import asyncio
import logging
import subprocess

READY_TIMEOUT = 300

class ProxyHandler:
    # This class is responsible for managing a proxy service in front of the target
    # Framework service.

    def __init__(
            self,
            log: logging.Logger,
    ):
        self.log = log

        # Port will be allocated lazily
        self._port: int = None
        self._lock = asyncio.Lock()
        self._procs: Dict[str, SupervisedProcess] = {}

    def _get_free_port(self) -> int:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind(("", 0))
            return s.getsockname()[1]

    @property
    def port(self) -> int:
        if self._port is None:
            self._port = self._get_free_port()
        return self._port


    def _make_tcp_ready(self, host: str, port: int):
        # Acts as a validation function for the supervised process running state
        async def _ready(_: SupervisedProcess) -> bool:
            try:
                r_, writer = await asyncio.open_connection(host, port)
                writer.close()
                await writer.wait_closed()
                return True
            except Exception:
                return False
        return _ready

    async def _drain_logs(self, proc: SupervisedProcess, key: str):
        # Allow logs from the process to be read and redirected to the appropriate
        # logger stream
        for stream_name, level in (("stdout", "info"), ("stderr", "error")):
            stream = getattr(proc.proc, stream_name)
            while True:
                line = await stream.readline()
                if not line:
                    break
                getattr(self.log, level)(f"{key}|{stream_name}> {line.decode().rstrip()}")

    async def _ensure_one(self, key: str, cmd: List[str], ready_func) -> bool:
        async with self._lock:
            if key in self._procs:
                return True

            proc = SupervisedProcess(
                key,
                *cmd,
                env=self.get_env(),
                ready_func=ready_func,
                ready_timeout=READY_TIMEOUT,
                log=self.log,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            self._procs[key] = proc

            try:
                await proc.start()
                if not await proc.ready():
                    self.log.error(f"{key} failed to become ready")
                    out, err = await proc.proc.communicate()
                    self.log.error(out.decode())
                    self.log.error(err.decode())
                    await proc.kill()
                    del self._procs[key]
                    return False

                asyncio.ensure_future(self._drain_logs(proc, key))
            except Exception:
                del self._procs[key]
                raise

            return True

    async def start(self) -> bool:
        # Start main proxy process toghether with its target proxied applications
        return NotImplemented


    async def stop(self) -> bool:
        # Stop all the processes started by this handler
        # Added just in case, but not used in the current implementation
        async with self._lock:
            for key, proc in self._procs.items():
                await proc.kill()
                del self._procs[key]
        return True


class OAuth2ProxyHandler(ProxyHandler):
    # This class is responsible for managing the oauth2-proxy process
    # and its target proxied applications

    def __init__(
            self,
            log: logging.Logger,
            oauth2_proxy_cmd: List[str],
            target_app_cmd: List[str],
    ):
        super().__init__(log)
        self.oauth2_proxy_cmd = oauth2_proxy_cmd
        self.target_app_cmd = target_app_cmd



# @click.command()
# @click.option('--destport', default=0, help='port that the webapp should end up running on; default 0 to be assigned a random free port')
# @click.option('--ip', default=None, help='Address to listen on')
# @click.option('--presentation-path', default='', help='presentation_path substitution variable')
# @click.option('--debug/--no-debug', default=False, help='To display debug level logs')
# @click.option('--logs/--no-logs', default=True, help='To display logs generated by the subprocess')
# @click.option('--authtype', type=click.Choice(['oauth', 'none'], case_sensitive=True), default='oauth')
# @click.option('--request-timeout', default=300, type=click.INT, help='timeout of proxy http calls to subprocess in seconds (default 300)')
# @click.option('--force-alive/--no-force-alive', default=False, help='Force the process to stay alive even if it is not ready')
# @click.option('--ready-check-path', default='/', help='URL path to poll for readiness (default /)')
# @click.option('--ready-timeout', default=10, help='Timeout for readiness request in seconds (default 60)')
# @click.option('--conda-env', default='', help="Name of conda env to activate before running process")
# @click.option('--forward-user-info/--no-forward-user-info', default=False, help='Forward a X-CDSDASHBOARDS-JH-USER HTTP header to process containing JupyterHub user data')
# @click.option('--progressive/--no-progressive', default=False, help='Progressively flush responses as they arrive (good for Voila)')
# @click.argument('command', nargs=-1, required=True)
# def main(destport, ip, presentation_path, debug, logs, authtype, request_timeout, conda_env, forward_user_info, progressive, ready_check_path, ready_timeout, force_alive, command):
def main(*args, **kwargs):
    """
    Run a proxy handler with the given arguments.
    """

    print("Running proxy handler with args:")

    # print(f"destport: {destport}")
    # print(f"ip: {ip}")
    # print(f"presentation_path: {presentation_path}")
    # print(f"debug: {debug}")
    # print(f"logs: {logs}")
    # print(f"authtype: {authtype}")
    # print(f"request_timeout: {request_timeout}")
    # print(f"force_alive: {force_alive}")
    # print(f"ready_check_path: {ready_check_path}")
    # print(f"ready_timeout: {ready_timeout}")
    # print(f"conda_env: {conda_env}")
    # print(f"forward_user_info: {forward_user_info}")
    # print(f"progressive: {progressive}")
    # print(f"command: {command}")

    print("args:", args)
